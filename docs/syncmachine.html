
  
  



  

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Chaplin.SyncMachine</title>
    
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Code highlighting -->
    <link rel="stylesheet" href="/assets/css/github.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script src="/assets/javascript/highlight.pack.js"></script>
    <script>
      $(function() {
        $('pre code').each(function(i, e) {hljs.highlightBlock(e)});
      });
    </script>
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">Chaplin</a>
          <ul class="nav">
            
            
            


  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
    	
    	<li><a href="/docs/index.html">Docs</a></li>
    	
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
    	
    	<li><a href="/pages/authors.html">Authors</a></li>
    	
    
  

  
    
    	
    	<li><a href="/pages/changelogs.html">Changelogs</a></li>
    	
    
  

  
    
  

  
    
  

  
    
    	
    	<li><a href="/pages/manifesto.html">Manifesto</a></li>
    	
    
  

  
    
  

  
    
  

  
    
  



          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        <div class="page-header">
  <h1>Chaplin.SyncMachine  <small> - API documentation</small></h1>

  
</div>

<div class="row">
  <div class="span12">
    <p>The  <code>Chaplin.SyncMachine</code> is a <a href="http://en.wikipedia.org/wiki/Finite-state_machine">finite-state machine</a> for synchronization of models/collections. There are three states in which a model or collection can be in; unsynced, syncing, and synced. When a state transition (unsynced, syncing, synced, and syncStateChange) occurs Backbone events are called on the model or collection.</p>

<h2 id="methods-of-chaplinsyncmachine">Methods of <code>Chaplin.SyncMachine</code></h2>

<p><a name="syncState"></a></p>

<h3 id="syncstate">syncState</h3>

<p>Returns the current synchronization state of the machine.</p>

<hr />

<p><a name="isUnsynced"></a></p>

<h3 id="isunsynced">isUnsynced</h3>

<p>Returns a boolean to determine if model or collection is unsynced.</p>

<hr />

<p><a name="isSynced"></a></p>

<h3 id="issynced">isSynced</h3>

<p>Returns a boolean to determine if model or collection is synced.</p>

<hr />

<p><a name="isSyncing"></a></p>

<h3 id="issyncing">isSyncing</h3>

<p>Returns a boolean to determine if model or collection is currently syncing.</p>

<hr />

<p><a name="unsync"></a></p>

<h3 id="unsync">unsync</h3>

<p>Sets the state machine’s state to <code>unsynced</code> then triggers any events listening for the <code>unsynced</code> and <code>syncStateChanged</code> events.</p>

<hr />

<p><a name="beginSync"></a></p>

<h3 id="beginsync">beginSync</h3>

<p>Sets the state machine’s state to <code>syncing</code> then triggers any events listening for the <code>syncing</code> and <code>syncStateChanged</code> events.</p>

<hr />

<p><a name="beginSync"></a></p>

<h3 id="finishsync">finishSync</h3>

<p>Sets the state machine’s state to <code>synced</code> then triggers any events listening for the <code>synced</code> and <code>syncStateChanged</code> events.</p>

<hr />

<p><a name="abortSync"></a></p>

<h3 id="abortsync">abortSync</h3>

<p>Sets state machine’s state back to the previous state if the state machine is in the <code>syncing</code> state. Then triggers any events listening for the previous state and <code>syncStateChanged</code> events.</p>

<hr />

<p><a name="unsynced"></a></p>

<h3 id="unsyncedcallback-contextthis">unsynced([callback], [context=this])</h3>

<p>Unsynced is a convenience method which will execute a callback in a specified context whenever the state machine enters into the <code>unsynced</code> state.</p>

<ul class="arguments">
  <li>
    <strong>callback</strong>: a function to be called when the `unsynced` event occurs
  </li>
  <li>
    <strong>context</strong>: the context in which the callback should execute in. Defaults to `this`.
  </li>
</ul>

<hr />

<p><a name="syncing"></a></p>

<h3 id="syncingcallback-contextthis">syncing([callback], [context=this])</h3>

<p>Syncing is a convenience method which will execute a callback in a specified context whenever the state machine enters into the <code>syncing</code> state.</p>

<ul class="arguments">
  <li>
    <strong>callback</strong>: a function to be called when the `syncing` event occurs
  </li>
  <li>
    <strong>context</strong>: the context in which the callback should execute in. Defaults to `this`.
  </li>
</ul>

<hr />

<p><a name="synced"></a></p>

<h3 id="syncedcallback-contextthis">synced([callback], [context=this])</h3>

<p>Synced is a convenience method which will execute a callback in a specified context whenever the state machine enters into the <code>synced</code> state.</p>

<ul class="arguments">
  <li>
    <strong>callback</strong>: a function to be called when the `synced` event occurs
  </li>
  <li>
    <strong>context</strong>: the context in which the callback should execute in. Defaults to `this`.
  </li>
</ul>

<hr />

<p><a name="syncStateChange"></a></p>

<h3 id="syncstatechangecallback-contextthis">syncStateChange([callback], [context=this])</h3>

<p>SyncStateChange is a convenience method which will execute a callback in a specified context whenever the state machine changes state.</p>

<ul class="arguments">
  <li>
    <strong>callback</strong>: a function to be called when the state of machine occurs
  </li>
  <li>
    <strong>context</strong>: the context in which the callback should execute in. Defaults to `this`.
  </li>
</ul>

<h2 id="usage">Usage</h2>

<p>The <code>Chaplin.SyncMachine</code> is a dependency of <code>Chaplin.Model</code> and <code>Chaplin.Collection</code> and should be used for complex synchronization of models and collections.  An example of this would be using a 3rd party. </p>

<pre><code class="coffeescript">
    define [
      'chaplin'
      'models/post' # Post model
    ], (Chaplin.Collection, Post) -&gt;

      class Posts extends Chaplin.Collection

        model: Post

        initialize: -&gt;
          super

          # Initialize the SyncMachine
          @initSyncMachine()

          # Will be called on every state change
          @syncStateChange announce

          fetch()

        # Custom fetch method which warrents
        # the sync machine
        fetch: =&gt;

          #Set the machine into `syncing` state
          @beginSync()

          # Do something interesting like calling
          # a 3rd party service
          $.get 'http://some-service.com/posts', @processPosts

        processPosts: (response) =&gt;
          # Exit if for some reason this collection was
          # disposed prior to the response
          return if @disposed

          # Update the collection
          @reset(if response and response.data then response.data else [])

          # Set the machine into `synced` state 
          @finishSync()

        announce: =&gt;
          console.debug 'state changed'
</code></pre>

<h2 id="dependencies">Dependencies</h2>

<p>No dependencies.</p>

<h2 id="code">Code</h2>
<pre><code class="coffeescript">
define [
  'underscore',
  'backbone',
  'chaplin/lib/utils'
  'chaplin/lib/subscriber'
  'chaplin/lib/sync_machine'
], (_, Backbone, utils, Subscriber, SyncMachine) -&gt;
  'use strict'

  class Model extends Backbone.Model

    # Mixin a Subscriber
    _(@prototype).extend Subscriber

    # Mixin a Deferred
    initDeferred: -&gt;
      _(this).extend $.Deferred()

    # Mixin a synchronization state machine
    initSyncMachine: -&gt;
      _(this).extend SyncMachine

    # This method is used to get the attributes for the view template
    # and might be overwritten by decorators which cannot create a
    # proper `attributes` getter due to ECMAScript 3 limits.
    getAttributes: -&gt;
      @attributes

    # Private helper function for serializing attributes recursively,
    # creating objects which delegate to the original attributes
    # when a property needs to be overwritten.
    serializeAttributes = (model, attributes, modelStack) -&gt;
      # Create a delegator on initial call
      unless modelStack
        delegator = utils.beget attributes
        modelStack = [model]
      else
        # Add model to stack
        modelStack.push model
      # Map model/collection to their attributes
      for key, value of attributes
        if value instanceof Model
          # Don’t change the original attribute, create a property
          # on the delegator which shadows the original attribute
          delegator ?= utils.beget attributes
          delegator[key] = if value is model or value in modelStack
            # Nullify circular references
            null
          else
            # Serialize recursively
            serializeAttributes(
              value, value.getAttributes(), modelStack
            )
        else if value instanceof Backbone.Collection
          delegator ?= utils.beget attributes
          delegator[key] = for item in value.models
            serializeAttributes(
              item, item.getAttributes(), modelStack
            )

      # Remove model from stack
      modelStack.pop()
      # Return the delegator if it was created, otherwise the plain attributes
      delegator or attributes

    # Return an object which delegates to the attributes
    # (i.e. an object which has the attributes as prototype)
    # so primitive values might be added and altered safely.
    # Map models to their attributes, recursively.
    serialize: (model) -&gt;
      serializeAttributes this, @getAttributes()

    # Disposal
    # --------

    disposed: false

    dispose: -&gt;
      return if @disposed

      # Fire an event to notify associated collections and views
      @trigger 'dispose', this

      # Unbind all global event handlers
      @unsubscribeAllEvents()

      # Remove all event handlers on this module
      @off()

      # If the model is a Deferred, reject it
      # This does nothing if it was resolved before
      @reject?()

      # Remove the collection reference, internal attribute hashes
      # and event handlers
      properties = [
        'collection',
        'attributes', 'changed'
        '_escapedAttributes', '_previousAttributes',
        '_silent', '_pending',
        '_callbacks'
      ]
      delete this[prop] for prop in properties

      # Finished
      @disposed = true

      # You’re frozen when your heart’s not open
      Object.freeze? this
</code></pre>

  </div>
</div>

      </div>

      <footer>
        <p>&copy; Chaplin 2011 - 2012</p>
      </footer>

    </div> <!-- /container -->

    
  </body>
</html>
